!(function () {
    'use strict';
    function u(t, e) {
        if (4 === t.length) {
            for (var i = 0, n = 0, o = 0; o < 4; o++) {
                if ((t[o].x !== e.min.x && t[o].x !== e.max.x) || (t[o].y !== e.min.y && t[o].y !== e.max.y)) return;
                (i += t[o].x), (n += t[o].y);
            }
            return i === 2 * (e.min.x + e.max.x) && n === 2 * (e.min.y + e.max.y);
        }
    }
    var t = {
        _toMercGeometry: function (t, e) {
            var i,
                n,
                o,
                r,
                a,
                s,
                u = [];
            for (e || (t[0] instanceof Array ? t[0][0] instanceof Array || (t = [t]) : (t = [[t]])), i = 0; i < t.length; i++) {
                for (r = [], n = 0; n < t[i].length; n++) {
                    for (a = [], o = 0; o < t[i][n].length; o++) (s = e ? L.latLng(t[i][n][o][1], t[i][n][o][0]) : t[i][n][o]), a.push(this._map.project(s, 0));
                    r.push(a);
                }
                u.push(r);
            }
            return u;
        },
        _getOriginalMercBoundary: function () {
            if (this._mercBoundary) return this._mercBoundary;
            var t, e, i;
            for (
                L.Util.isArray(this.options.boundary)
                    ? (this._mercBoundary = this._toMercGeometry(this.options.boundary))
                    : ((this._mercBoundary = []),
                      (i = function (t) {
                          'GeometryCollection' === t.type
                              ? t.geometries.forEach(i)
                              : 'Feature' === t.type
                              ? i(t.geometry)
                              : 'FeatureCollection' === t.type
                              ? t.features.forEach(i)
                              : 'Polygon' === t.type
                              ? (this._mercBoundary = this._mercBoundary.concat(this._toMercGeometry([t.coordinates], !0)))
                              : 'MultiPolygon' === t.type && (this._mercBoundary = this._mercBoundary.concat(this._toMercGeometry(t.coordinates, !0)));
                      }.bind(this))(this.options.boundary)),
                    this._mercBbox = new L.Bounds(),
                    e = 0;
                e < this._mercBoundary.length;
                e++
            )
                (t = new L.Bounds(this._mercBoundary[e][0])), this._mercBbox.extend(t.min), this._mercBbox.extend(t.max);
            return this._mercBoundary;
        },
        _getClippedGeometry: function (t, e) {
            for (var i, n, o, r, a = [], s = 0; s < t.length; s++)
                if (((i = []), 0 !== (n = L.PolyUtil.clipPolygon(t[s][0], e)).length)) {
                    for (i.push(n), r = 1; r < t[s].length; r++) 0 < (o = L.PolyUtil.clipPolygon(t[s][r], e)).length && i.push(o);
                    a.push(i);
                }
            if (0 === a.length) return { isOut: !0 };
            for (s = 0; s < a.length; s++) {
                if (!u(a[s][0], e)) return { geometry: a };
                if (1 === a[s].length) return { isIn: !0 };
                for (r = 1; r < a[s].length; r++) if (!u(a[s][r], e)) return { geometry: a };
            }
            return { isOut: !0 };
        },
        _getTileGeometry: function (t, e, i, n) {
            if (!this.options.boundary) return { isIn: !0 };
            var o = t + ':' + e + ':' + i,
                r = Math.pow(2, i),
                a = this._boundaryCache;
            if (a[o]) return a[o];
            var s = this._getOriginalMercBoundary(),
                u = this.options.tileSize,
                r = new L.Bounds(new L.Point((t * u) / r, (e * u) / r), new L.Point(((t + 1) * u) / r, ((e + 1) * u) / r));
            return n || r.intersects(this._mercBbox)
                ? 0 === i
                    ? ((a[o] = { geometry: s }), a[o])
                    : (i = this._getTileGeometry(Math.floor(t / 2), Math.floor(e / 2), i - 1, !0)).isOut || i.isIn
                    ? i
                    : ((a[o] = this._getClippedGeometry(i.geometry, r)), a[o])
                : { isOut: !0 };
        },
        _drawTileInternal: function (r, t, e, a) {
            var i,
                s,
                u,
                l,
                h,
                y,
                n,
                o = this._getZoomForUrl(),
                c = this._getTileGeometry(t.x, t.y, o);
            c.isOut
                ? a()
                : ((i = this.options.tileSize),
                  (s = i * t.x),
                  (u = i * t.y),
                  (l = Math.pow(2, o)),
                  (h = r.getContext('2d')),
                  (y = new Image()),
                  (n = function () {
                      var t, e, i, n, o;
                      if (!c.isIn) {
                          for (o = c.geometry, h.beginPath(), t = 0; t < o.length; t++)
                              for (e = 0; e < o[t].length; e++)
                                  if (0 !== o[t][e].length)
                                      for (h.moveTo(o[t][e][0].x * l - s, o[t][e][0].y * l - u), i = 1; i < o[t][e].length; i++) h.lineTo(o[t][e][i].x * l - s, o[t][e][i].y * l - u);
                          h.clip();
                      }
                      (n = h.createPattern(y, 'repeat')), h.beginPath(), h.rect(0, 0, r.width, r.height), (h.fillStyle = n), h.fill(), a();
                  }),
                  this.options.crossOrigin && (y.crossOrigin = ''),
                  (y.onload = function () {
                      (r.complete = !0), setTimeout(n, 0);
                  }),
                  (y.src = e));
        },
        onAdd: function (t) {
            (L.TileLayer.Canvas || L.TileLayer).prototype.onAdd.call(this, t), this.options.trackAttribution && (t.on('moveend', this._updateAttribution, this), this._updateAttribution());
        },
        onRemove: function (t) {
            var e;
            (L.TileLayer.Canvas || L.TileLayer).prototype.onRemove.call(this, t),
                this.options.trackAttribution &&
                    (t.off('moveend', this._updateAttribution, this),
                    this._attributionRemoved || ((e = L.TileLayer.BoundaryCanvas.prototype.getAttribution.call(this)), t.attributionControl.removeAttribution(e)));
        },
        _updateAttribution: function () {
            var t = this._getOriginalMercBoundary(),
                e = this._map.getBounds(),
                e = L.bounds(this._map.project(e.getSouthWest(), 0), this._map.project(e.getNorthEast(), 0)),
                t = this._getClippedGeometry(t, e);
            this._attributionRemoved !== !!t.isOut &&
                ((e = L.TileLayer.BoundaryCanvas.prototype.getAttribution.call(this)),
                this._map.attributionControl[t.isOut ? 'removeAttribution' : 'addAttribution'](e),
                (this._attributionRemoved = !!t.isOut));
        }
    };
    '0.8' <= L.version
        ? (L.TileLayer.BoundaryCanvas = L.TileLayer.extend({
              options: { boundary: null },
              includes: t,
              initialize: function (t, e) {
                  L.TileLayer.prototype.initialize.call(this, t, e),
                      (this._boundaryCache = {}),
                      (this._mercBoundary = null),
                      (this._mercBbox = null),
                      this.options.trackAttribution && ((this._attributionRemoved = !0), (this.getAttribution = null));
              },
              createTile: function (t, e) {
                  var i = document.createElement('canvas'),
                      n = this.getTileUrl(t);
                  return (i.width = i.height = this.options.tileSize), this._drawTileInternal(i, t, n, L.bind(e, null, null, i)), i;
              }
          }))
        : (L.TileLayer.BoundaryCanvas = L.TileLayer.Canvas.extend({
              options: { boundary: null },
              includes: t,
              initialize: function (t, e) {
                  L.Util.setOptions(this, e),
                      L.Util.setOptions(this, { async: !0 }),
                      (this._url = t),
                      (this._boundaryCache = {}),
                      (this._mercBoundary = null),
                      (this._mercBbox = null),
                      this.options.trackAttribution && ((this._attributionRemoved = !0), (this.getAttribution = null));
              },
              drawTile: function (t, e) {
                  var i = L.extend({}, e);
                  this._adjustTilePoint(i),
                      (i = this.getTileUrl(i)),
                      this._drawTileInternal(t, e, i, L.bind(this.tileDrawn, this, t)),
                      this._getTileSize() !== this.options.tileSize && (t.style.width = t.style.height = this._getTileSize() + 'px');
              }
          })),
        (L.TileLayer.boundaryCanvas = function (t, e) {
            return new L.TileLayer.BoundaryCanvas(t, e);
        }),
        (L.TileLayer.BoundaryCanvas.createFromLayer = function (t, e) {
            return new L.TileLayer.BoundaryCanvas(t._url, L.extend({}, t.options, e));
        });
})();
